--- ../src/common/gres.c	2011-09-12 17:07:40.000000000 +0300
@@ -165,7 +165,7 @@
 			       slurm_gres_context_t *context_ptr);
 static void	_node_state_dealloc(gres_state_t *gres_ptr);
 static void *	_node_state_dup(void *gres_data);
-static void	_node_state_log(void *gres_data, char *node_name,
+static int	_node_state_log(void *gres_data, char *node_name,
 				char *gres_name);
 static int	_parse_gres_config(void **dest, slurm_parser_enum_t type,
 				   const char *key, const char *value,
@@ -339,7 +339,7 @@
 		gres_debug = true;
 	else
 		gres_debug = false;
-
+	gres_debug = true;
 	if (gres_context_cnt >= 0)
 		goto fini;
 
@@ -1854,7 +1854,7 @@
 	slurm_mutex_unlock(&gres_context_lock);
 }
 
-static void _node_state_log(void *gres_data, char *node_name, char *gres_name)
+static int _node_state_log(void *gres_data, char *node_name, char *gres_name)
 {
 	gres_node_state_t *gres_node_ptr;
 	int i;
@@ -1890,6 +1890,7 @@
 		info("  topo_gres_cnt_avail[%d]:%u",i,
 		     gres_node_ptr->topo_gres_cnt_avail[i]);
 	}
+	return gres_node_ptr->gres_cnt_avail - gres_node_ptr->gres_cnt_alloc;
 }
 
 /*
@@ -1897,14 +1898,14 @@
  * IN gres_list - generated by gres_plugin_node_config_validate()
  * IN node_name - name of the node for which the gres information applies
  */
-extern void gres_plugin_node_state_log(List gres_list, char *node_name)
+extern int gres_plugin_node_state_log(List gres_list, char *node_name)
 {
-	int i;
+	int i, remaining = 0;
 	ListIterator gres_iter;
 	gres_state_t *gres_ptr;
 
 	if (!gres_debug || (gres_list == NULL))
-		return;
+		return 0;
 
 	(void) gres_plugin_init();
 
@@ -1915,13 +1916,19 @@
 			if (gres_ptr->plugin_id !=
 			    gres_context[i].plugin_id)
 				continue;
-			_node_state_log(gres_ptr->gres_data, node_name,
-					gres_context[i].gres_name);
+			if (strcmp(gres_context[i].gres_name,"gpu") == 0)
+				remaining = _node_state_log(gres_ptr->gres_data, node_name,
+						gres_context[i].gres_name);
+			else
+				_node_state_log(gres_ptr->gres_data, node_name,
+						gres_context[i].gres_name);
 			break;
 		}
 	}
 	list_iterator_destroy(gres_iter);
 	slurm_mutex_unlock(&gres_context_lock);
+
+	return remaining;
 }
 
 static void _job_state_delete(void *gres_data)
@@ -4410,3 +4417,36 @@
 	slurm_mutex_unlock(&gres_context_lock);
 }
 
+/*
+returns number of gres types defined
+*/
+extern int gres_cnt() {
+	return gres_context_cnt;
+}
+
+/*
+returns number of gpus for a specific node
+*/
+extern int gres_job_gpu_count(List job_gres_list) {
+	int i;
+	ListIterator job_gres_iter;
+	gres_state_t *job_gres_ptr;
+	gres_job_state_t  *job_gres_ptr2;
+
+	if (job_gres_list == NULL)
+		return 0;
+
+	(void) gres_plugin_init();
+	job_gres_iter = list_iterator_create(job_gres_list);
+	while ((job_gres_ptr = (gres_state_t *) list_next(job_gres_iter))) {
+		for (i=0; i<gres_context_cnt; i++) {
+			if (strcmp(gres_context[i].gres_name,"gpu") == 0) {
+				job_gres_ptr2 = (gres_job_state_t *)
+					job_gres_ptr->gres_data;
+				return job_gres_ptr2->gres_cnt_alloc;
+			}
+		}
+	}
+	return 0;
+}
+
